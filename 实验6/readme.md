### 第一题

这一题需要一直读取到结束，可以直接参照题目中给的方法。

```c++
char a[50];
int cnt = 0;
while (scanf("%s", a) != EOF)
    cnt++;
```

这里注意`%s`读取到空格就会停止，这里每行都是由空格隔开的两个字符串，所以数完了之后要记得除以2再输出。

#### 详细说明

`scanf()` 是用于标准输入的 **函数**，具有返回值。  
当函数读取到内容时，会返回读取到的输入的个数。如果遇到`EOF`（文件结束符），返回`EOF`，也就是`-1`。

##### 举例：

```c++
#include <stdio.h>

int main(){
    int a, c;
    int cnt = 0;
    while (1){
        cnt++;
        int b = scanf("%d %d", &a, &c);
        printf("%d\n", b);
        if (cnt >= 5)
            break;
    }
}
```

##### 输入：

`12 23 24`

##### 返回：

```text
2
1
-1
-1
-1
```

##### 说明：

代码依次读取两个数字到`a`、`c`，并打印`scanf`的返回值。  
第一次读取读到两个数字，返回`2`，第二次读取时输入只有一个数字，所以只读取到`24`，返回`1`；后面三次都没有读取到，返回`-1`。

`EOF`用来标记文件结束，在手动输入时可以通过`ctrl+z`来触发。  
在C中，EOF是值为-1的宏。  
`#define EOF (-1)`

### 第二题

循环10次读取就可以了，当然也可以用第一题的方式。

### 第三题

这里一样，使用第一题的方式。  
最小公倍数 = a * b / 最大公因数  
输出别忘了换行 :<

### 第四题

很简单，读取比较就可以了。用`fgets`读取一整行的话，注意后面会有换行符，可以考虑比较时后面加上，比如`strcmp(t, "int\n")`。

这里再提供一种可能不一样的思路：  
先定义两个数组，一个存储类型，另一个存储类型对应的大小，比较时只需要遍历一遍列表，挨个比较，相等时根据索引返回存储大小数组的对应项。  
示例代码用的就是这种方法。（不知道C里有没有字典 :）

### 第五题

关于题目里的模块化编程...  
例子太简单了，这里没必要分开成函数，不过也不是不行...  
我就不展示了...  
如果要分成不同函数的话，思路大概如下：

```c++
void generate() { // 计算 1000000 以内的斐波那契数列
}

bool judge(int x) { // 遍历生成的数列，判断数字在不在里面
}

int main(){ // 输入数字，生成数列，调用函数判断，输出
}
```

### 第六题
这题题目描述有坑，是字符串的翻转，不需要去除前导0，比如`12340`翻转后为`04321`。  
没必要硬用函数，也没必要递归。~~其实我也不知道怎么写成递归~~  
如果想在函数中直接返回数组的话，可以通过`static`关键字实现。  
#### 例子（返回字符数组）
```c++
char *reverse(char s[]) {
    static char reversed[100] = {0};
    for (int i = strlen(s) - 1, j = 0; i >= 0; i--, j++) {
        reversed[j] = s[i];
    }
    return reversed;
}
```

### 第七题

这题很简单吧，不用再说了吧，没有坑。
~~没复杂到需要用函数，怎么快怎么写就完事了~~

### 第八题

这题比较适合把判断的逻辑拆分出一个函数来写，可以让main函数条理清晰。  
额，感觉没什么难的，照着要求枚举就可以了。  
- `%04d`可以用0补到4位长度
- `sprintf(s, "%04d", year);`可以把year补到4位输出到字符数组s中

### 第九题
写函数迭代就可以了。  
注意名字是**字符串**不是字符  

### 第十题
首先，考虑1了吗   :)  
指数为1的时候省略指数了吗？  
边界条件有点多，记得多用几个数据试一试...  
~~还是Py好用~~